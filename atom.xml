<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MASAKA</title>
  
  <subtitle>即使已经消亡,星光依然照耀我们</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://masaka.acehalo.com/"/>
  <updated>2020-12-23T01:10:13.773Z</updated>
  <id>http://masaka.acehalo.com/</id>
  
  <author>
    <name>MASAKA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【草稿】段页式存储管理简述</title>
    <link href="http://masaka.acehalo.com/2020/12/22/memo-manage-2ae0d189/"/>
    <id>http://masaka.acehalo.com/2020/12/22/memo-manage-2ae0d189/</id>
    <published>2020-12-22T17:56:08.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="段页式存储管理简述"><a href="#段页式存储管理简述" class="headerlink" title="段页式存储管理简述"></a>段页式存储管理简述</h1><p>今天来简单聊聊操作系统的内存管理。<br>目前主要的管理方式是段页式管理，顾名思义，结合了段式管理和页式管理两种方式。  </p><p>对于应用程序，申请内存时都是申请连续的一大片空间，如果直接分配连续的物理内存，则会产生很多内存碎片区域，这些碎片区域不满足程序需要的连续空间大小，所以会造成内存使用率低，而整理这些区域的代价又很大，所以需要增加映射关系，即将应用程序申请的连续空间映射到离散的物理内存空间。于是，有了不同的内存管理方式。</p><h2 id="分页式管理"><a href="#分页式管理" class="headerlink" title="分页式管理"></a>分页式管理</h2><p>我们先来讲讲页式管理方式。</p><p>分页式管理将应用程序申请的内存分为页，通常一页为4K，然后将物理内存分为块，通常每块的大小等于每页的大小，然后，使用页表保了页号和块号的对应关系这样，应用程序访问内存时通过查询页表即可访问到内存。</p><p>页表示例：</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><h2 id="分段式管理"><a href="#分段式管理" class="headerlink" title="分段式管理"></a>分段式管理</h2><p>我们再来聊聊分段式管理方式。</p><p>分段式管理是将应用程序申请的内存分成段，每一段对应的物理内存都是连续的，寻址时同样也需要映射关系。</p><p>段表示例：</p><table><thead><tr><th>段号</th><th>段长</th><th>基址</th></tr></thead><tbody><tr><td>0</td><td>30K</td><td>40K</td></tr><tr><td>1</td><td>60K</td><td>80K</td></tr></tbody></table><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><p>段页式管理结合了段式管理和页式管理。先查段表，然后查页表。每一个段对应一张页表。</p><p>段表示例：</p><table><thead><tr><th>段号</th><th>页表长度</th><th>页表始址</th></tr></thead><tbody><tr><td>0</td><td>2</td><td></td></tr><tr><td>1</td><td>3</td><td></td></tr></tbody></table><p>页表示例：</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      段页式存储管理简述。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】限流算法简述</title>
    <link href="http://masaka.acehalo.com/2020/12/22/limit-fe66b2cf/"/>
    <id>http://masaka.acehalo.com/2020/12/22/limit-fe66b2cf/</id>
    <published>2020-12-22T17:55:05.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="限流算法简述"><a href="#限流算法简述" class="headerlink" title="限流算法简述"></a>限流算法简述</h1><p>这里主要简述下四种限流算法：计数器算法，滑动窗口算法，漏桶算法，令牌桶算法。</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><p>这种算法存在的问题就是不平滑，存在边界。</p><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。<br>当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略。</p>]]></content>
    
    <summary type="html">
    
      限流算法简述。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】TCP IP简述</title>
    <link href="http://masaka.acehalo.com/2020/12/22/tcp-ip-9055af38/"/>
    <id>http://masaka.acehalo.com/2020/12/22/tcp-ip-9055af38/</id>
    <published>2020-12-22T17:54:24.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP简述"><a href="#TCP-IP简述" class="headerlink" title="TCP IP简述"></a>TCP IP简述</h1><p>TCP/IP全称：Transmission Control Protocol/Internet Protocol<br>中文是：传输控制协议/网际协议</p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><table><thead><tr><th>OSI七层模型</th></tr></thead><tbody><tr><td>应用层</td><td></td></tr><tr><td>表示层</td><td></td></tr><tr><td>会话层</td><td></td></tr><tr><td>传输层</td><td></td></tr><tr><td>网络层</td><td></td></tr><tr><td>数据链路层</td><td></td></tr><tr><td>物理层</td><td></td></tr></tbody></table><table><thead><tr><th>TCP/IP四层模型</th></tr></thead><tbody><tr><td>应用层</td><td></td><td></td></tr><tr><td>传输层</td><td></td></tr><tr><td>网络层</td><td></td></tr><tr><td>网络接口层</td><td></td></tr></tbody></table><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp 等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP协议是面向字节流的协议，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。</p><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态。</p><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。</p><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求。</p><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态。</p><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。</p><p>如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量rwnd来表示接收窗口的大小。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><h4 id="慢开始-和-拥塞避免"><a href="#慢开始-和-拥塞避免" class="headerlink" title="慢开始 和 拥塞避免"></a>慢开始 和 拥塞避免</h4><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>当cwnd &gt; ssthresh（慢开始门限）时，改用拥塞避免算法，拥塞避免算法每经过一个往返时间cwnd加1。</p><p>当cwnd = ssthresh时，既可以用慢开始也可以使用拥塞避免算法。</p><p>当cwnd &lt; ssthresh时，慢开始算法。</p><p>当网络出现超时，ssthresh = cwnd / 2，同时设置拥塞窗口cwnd=1.进入慢开始算法。</p><h4 id="快重传-和-快恢复"><a href="#快重传-和-快恢复" class="headerlink" title="快重传 和 快恢复"></a>快重传 和 快恢复</h4><p>快重传算法要求接收方不要等待自己发送数据才进行捎带确认，而是立即发送确认。即使收到失序的报文段对已发送的报文段的重复确认。发送方一连收到3个重复确认就应当立即进行重传。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，发送方调整门限值ssthresh =cwnd/2，同时设置拥塞窗口cwnd=ssthresh ，并开始拥塞避免算法。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><hr><p>参考：<a href="https://mp.weixin.qq.com/s/ypzml4GEggNlbr-QAVo6CA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ypzml4GEggNlbr-QAVo6CA</a></p>]]></content>
    
    <summary type="html">
    
      TCP IP简述。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】Select,Poll,Epoll简介</title>
    <link href="http://masaka.acehalo.com/2020/12/22/select-poll-epoll-ada55c01/"/>
    <id>http://masaka.acehalo.com/2020/12/22/select-poll-epoll-ada55c01/</id>
    <published>2020-12-22T17:53:40.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Select-Poll-Epoll简介"><a href="#Select-Poll-Epoll简介" class="headerlink" title="Select,Poll,Epoll简介"></a>Select,Poll,Epoll简介</h1><p>Select,Poll,Epoll这三个都是同步IO，为什么这么说呢，因为在网络IO处理过程中，把数据从内核缓冲区复制到应用程序缓冲区这步是阻塞的，真正的异步IO，应该是操作系统把数据拷贝到应用程序的缓冲区后再通知应用程序处理。</p><p>具体内容，有篇文章写的挺好，我就先不在这里写了，等有时间再补上，可以先参考：<a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1005481</a></p>]]></content>
    
    <summary type="html">
    
      Select,Poll,Epoll简介。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】分布式系统CAP理论简述</title>
    <link href="http://masaka.acehalo.com/2020/12/22/cap-9162735e/"/>
    <id>http://masaka.acehalo.com/2020/12/22/cap-9162735e/</id>
    <published>2020-12-22T17:52:41.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>在一个分布式计算系统中，只能同时满足下列的两点:</p><p>一致性 ─ 每次访问都能获得最新数据但可能会收到错误响应<br>可用性 ─ 每次访问都能收到非错响应，但不保证获取到最新数据<br>分区容错性 ─ 在任意分区网络故障的情况下系统仍能继续运行<br>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</p><p>CP ─ 一致性和分区容错性<br>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p><p>AP ─ 可用性与分区容错性<br>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p><p>如果业务需求允许最终一致性，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p><p>更多内容可以参考：<a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/" target="_blank" rel="noopener">https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/</a></p>]]></content>
    
    <summary type="html">
    
      分布式系统CAP理论简述。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】Raft协议简述</title>
    <link href="http://masaka.acehalo.com/2020/12/22/raft-12e1daa8/"/>
    <id>http://masaka.acehalo.com/2020/12/22/raft-12e1daa8/</id>
    <published>2020-12-22T17:51:41.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft协议简述"><a href="#Raft协议简述" class="headerlink" title="Raft协议简述"></a>Raft协议简述</h1><p>Raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。</p><p>Raft协议相对于Paxos协议更易于理解。</p><p>Raft协议主要有两部分需要了解，一是Leader选举，二是日志同步。</p><p>先贴两个参考链接吧，有时间再来完善这篇文章。</p><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a></p><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p>]]></content>
    
    <summary type="html">
    
      Raft协议简述。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】Kafka简介</title>
    <link href="http://masaka.acehalo.com/2020/12/22/kafka-ed02a6e7/"/>
    <id>http://masaka.acehalo.com/2020/12/22/kafka-ed02a6e7/</id>
    <published>2020-12-22T17:50:45.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>这里主要先讲下Kafka的高可用机制吧。主要是ISR。</p><h2 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h2><p>在Kafka 中备份日志文件被称为replica，replica 又分为leader replica 和follower replica，而follower replica存在的唯一目的就是防止消息丢失，并不参与具体的业务逻辑的交互。只有leader 才参与服务，follower的作用就是充当leader的候补，平时的操作也只有信息同步。ISR （in-sync replica）也就是这组与leader保持同步的replica集合，我们要保证不丢消息，首先要保证ISR的存活（至少有一个备份存活），并且消息提交成功。那存活的概念是什么呢，就是说不仅需要机器正常，还需要跟上leader的消息进度，当达到一定程度的时候就会认为“非存活”状态。</p>]]></content>
    
    <summary type="html">
    
      Kafka简介。文章还未完成，还是草稿状态，等博主有时间了再好好写写。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【草稿】JAVA垃圾回收器ParNew，CMS和G1简介</title>
    <link href="http://masaka.acehalo.com/2020/12/22/jvm-gc-b909043c/"/>
    <id>http://masaka.acehalo.com/2020/12/22/jvm-gc-b909043c/</id>
    <published>2020-12-22T17:48:33.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA垃圾回收器ParNew，CMS和G1简介"><a href="#JAVA垃圾回收器ParNew，CMS和G1简介" class="headerlink" title="JAVA垃圾回收器ParNew，CMS和G1简介"></a>JAVA垃圾回收器ParNew，CMS和G1简介</h1><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>年轻代的垃圾收集器，使用复制清除算法。</p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><p>CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤：</p><p>初始标记（CMS initial mark）<br>并发标记（CMS concurrent mark）<br>重新标记（CMS remark）<br>并发清除（CMS concurrent sweep）  </p><p>其中，初始标记、重新标记这两个步骤仍然需要Stop-the-world。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</p><p>CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有两次短暂的暂停（初始标记和重新标记），达到了近似并发的目的。</p><p>CMS收集器优点：</p><p>并发收集、低停顿。</p><p>CMS收集器缺点：</p><p>CMS收集器对CPU资源非常敏感。<br>CMS收集器无法处理浮动垃圾（Floating Garbage）。<br>CMS收集器是基于标记-清除算法，该算法的缺点都有。<br>CMS收集器之所以能够做到并发，根本原因在于采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p><p>G1具备如下特点：</p><p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</p><p>分代收集</p><p>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p><p>可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</p><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间。</p><p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region。其实这个数字既可以手动调整，G1也会根据堆大小自动进行调整。</p><p>G1收集的运作过程大致如下：</p><p>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p><p>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</p><p>筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p>]]></content>
    
    <summary type="html">
    
      JAVA垃圾回收器ParNew，CMS和G1简介。文章还未完成，还是草稿状态。。。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的一些设备延迟</title>
    <link href="http://masaka.acehalo.com/2020/12/22/latency-dbfa7308/"/>
    <id>http://masaka.acehalo.com/2020/12/22/latency-dbfa7308/</id>
    <published>2020-12-22T17:45:48.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Latency-Comparison-Numbers"><a href="#Latency-Comparison-Numbers" class="headerlink" title="Latency Comparison Numbers"></a>Latency Comparison Numbers</h2><table><thead><tr><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>L1 cache reference</td><td>0.5 ns</td></tr><tr><td>Branch mispredict</td><td>5 ns</td></tr><tr><td>L2 cache reference</td><td>7   ns</td><td>14x L1 cache</td></tr><tr><td>Mutex lock/unlock</td><td>25   ns</td></tr><tr><td>Main memory reference</td><td>100 ns</td><td>20x L2 cache, 200x L1 cache</td></tr><tr><td>Compress 1K bytes with Zippy</td><td>10,000 ns = 10 us</td><td></td></tr><tr><td>Send 1 KB bytes over 1 Gbps network</td><td>10,000   ns</td><td>10 us</td></tr><tr><td>Read 4 KB randomly from SSD*</td><td>150,000   ns = 150 us</td><td>~1GB/sec SSD</td></tr><tr><td>Read 1 MB sequentially from memory</td><td>250,000   ns = 250 us</td></tr><tr><td>Round trip within same datacenter</td><td>500,000   ns = 500 us</td></tr><tr><td>Read 1 MB sequentially from SSD*</td><td>1,000,000   ns=1,000 us=1 ms</td><td>~1GB/sec SSD, 4X memory</td></tr><tr><td>Disk seek</td><td>10,000,000   ns=10,000 us=10 ms</td><td>20x datacenter roundtrip</td></tr><tr><td>Read 1 MB sequentially from 1 Gbps</td><td>10,000,000   ns=10,000 us=10 ms</td><td>40x memory, 10X SSD</td></tr><tr><td>Read 1 MB sequentially from disk</td><td>30,000,000   ns=30,000 us=30 ms</td><td>120x memory, 30X SSD</td></tr><tr><td>Send packet CA-&gt;Netherlands-&gt;CA</td><td>150,000,000   ns=150,000 us=150 ms</td></tr></tbody></table><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>1 ns = 10^-9 seconds</p><p>1 us = 10^-6 seconds = 1,000 ns</p><p>1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</p>]]></content>
    
    <summary type="html">
    
      常见的一些设备延迟。主要用于估算一些服务性能。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过Telegram Bot向Wordpress博客发送文章</title>
    <link href="http://masaka.acehalo.com/2020/07/19/telegram-to-wordpress/"/>
    <id>http://masaka.acehalo.com/2020/07/19/telegram-to-wordpress/</id>
    <published>2020-07-19T23:00:00.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<p>博主有个万年不更新的自建Wordpress博客，主要是没啥写的，想着利用一下，以后就不发微博了，改用博客，但是如果只是发表一些想法的话，打开文章发布页面太麻烦了，索性就利用Telegram Bot功能，直接通过Telegram Bot发送。  </p><p>如何创建一个Telegram Bot就不在这里细说了，百度一堆，其他的其实也没啥要说的。</p><p>启动之后，从Telegram上找到自己的Bot，然后/w空格之后写想要发布的内容就可以了。</p><p>直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">from telegram.ext import Updater, CommandHandler</span><br><span class="line">import xmlrpc.client</span><br><span class="line">import arrow</span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def start(update, context):</span><br><span class="line">    context.bot.send_message(chat_id=update.effective_chat.id, text=&quot;I&apos;m a bot, please talk to me!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def w(update, context):</span><br><span class="line">    print(update)</span><br><span class="line">    if update.message.chat.username != &apos;你的Telegram用户名&apos;:</span><br><span class="line">        print(&quot;not admin&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    user_says = &quot; &quot;.join(context.args)</span><br><span class="line">    wp_url = &quot;https://你的Wordpress博客的地址/xmlrpc.php&quot;</span><br><span class="line">    server = xmlrpc.client.ServerProxy(wp_url)</span><br><span class="line">    post = &#123;</span><br><span class="line">        &quot;title&quot;: &quot;动态 | &quot;+str(arrow.utcnow()),</span><br><span class="line">        &quot;description&quot;: user_says</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = server.metaWeblog.newPost(0, &quot;你的Wordpress博客登录名&quot;, &quot;你的Wordpress博客密码&quot;, post, True)</span><br><span class="line">    update.message.reply_text(&quot;sent:&quot; + str(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 你的Http代理地址，主要用于本地调试</span><br><span class="line">request_kwargs = &#123;</span><br><span class="line">    &quot;proxy_url&quot;: &quot;http://localhost:3000&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updater = Updater(token=&apos;你的Telegram Bot的Token&apos;, use_context=True,</span><br><span class="line">                  request_kwargs=request_kwargs)</span><br><span class="line"></span><br><span class="line">dispatcher = updater.dispatcher</span><br><span class="line">dispatcher.add_handler(CommandHandler(&apos;start&apos;, start))</span><br><span class="line">dispatcher.add_handler(CommandHandler(&quot;w&quot;, w))</span><br><span class="line"></span><br><span class="line">updater.start_polling()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      记录下通过Telegram Bot向Wordpress博客发送文章。
    
    </summary>
    
      <category term="其他" scheme="http://masaka.acehalo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="教程" scheme="http://masaka.acehalo.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java使用Imap收邮件和Smtp发邮件</title>
    <link href="http://masaka.acehalo.com/2020/02/23/java-imap-smtp/"/>
    <id>http://masaka.acehalo.com/2020/02/23/java-imap-smtp/</id>
    <published>2020-02-23T19:00:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>废话少说，直接上代码：</p><ol><li><p>常量部分：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final static String SSL_FACTORY = &quot;javax.net.ssl.SSLSocketFactory&quot;;</span><br><span class="line">private final static String USER_NAME = &quot;xxx@xxx.com&quot;;</span><br><span class="line">private final static String PASSWORD = &quot;xxx&quot;;</span><br><span class="line"></span><br><span class="line">private final static String SERVER_IMAP = &quot;imap.xxx.com&quot;;</span><br><span class="line">private final static String PROTOCOL_IMAP = &quot;imap&quot;;</span><br><span class="line">private final static Integer PORT_IMAP = 993;</span><br><span class="line"></span><br><span class="line">private final static String SERVER_SMTP = &quot;smtp.xxx.com&quot;;</span><br><span class="line">private final static String PROTOCOL_SMTP = &quot;smtp&quot;;</span><br><span class="line">private final static Integer PORT_SMTP = 465;</span><br></pre></td></tr></table></figure></li><li><p>Imap收邮件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Properties props = new Properties();</span><br><span class="line">//设置协议 imap</span><br><span class="line">props.setProperty(&quot;mail.transport.PROTOCOL&quot;, PROTOCOL_IMAP);</span><br><span class="line">//设置 imap 服务地址</span><br><span class="line">props.setProperty(&quot;mail.imap.host&quot;, SERVER_IMAP);</span><br><span class="line">//使用加密连接方式</span><br><span class="line">props.setProperty(&quot;mail.imap.ssl.enable&quot;, &quot;true&quot;);</span><br><span class="line">//此处的SSL_FACTORY为javax.net.ssl.SSLSocketFactory</span><br><span class="line">props.setProperty(&quot;mail.imap.socketFactory.class&quot;, SSL_FACTORY);</span><br><span class="line">Session session = Session.getInstance(props);</span><br><span class="line">//打印日志</span><br><span class="line">session.setDebug(true);</span><br><span class="line">Store store = session.getStore(PROTOCOL_IMAP);</span><br><span class="line">store.connect(SERVER_IMAP, PORT_IMAP, USER_NAME, PASSWORD);</span><br><span class="line">Folder folder = store.getFolder(&quot;INBOX&quot;);</span><br><span class="line">folder.open(Folder.READ_ONLY);</span><br><span class="line">Message[] messages = folder.getMessages();</span><br><span class="line">store.close();</span><br></pre></td></tr></table></figure></li><li><p>Smtp发邮件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Properties props = new Properties();</span><br><span class="line">//设置协议 smtp</span><br><span class="line">props.setProperty(&quot;mail.transport.PROTOCOL&quot;, PROTOCOL_SMTP);</span><br><span class="line">//设置 smtp 服务地址</span><br><span class="line">props.setProperty(&quot;mail.smtp.host&quot;, SERVER_SMTP);</span><br><span class="line">//设置 smtp 服务端口</span><br><span class="line">props.setProperty(&quot;mail.smtp.port&quot;, String.valueOf(PORT_SMTP));</span><br><span class="line">//使用加密连接方式</span><br><span class="line">props.setProperty(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);</span><br><span class="line">//此处的SSL_FACTORY为javax.net.ssl.SSLSocketFactory</span><br><span class="line">props.setProperty(&quot;mail.smtp.socketFactory.class&quot;, SSL_FACTORY);</span><br><span class="line">//需要认证</span><br><span class="line">props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">Session session = Session.getDefaultInstance(props, new Authenticator() &#123;</span><br><span class="line">    protected PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">        return new PasswordAuthentication(USER_NAME, PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//打印日志</span><br><span class="line">session.setDebug(true);</span><br><span class="line">Message msg = new MimeMessage(session);</span><br><span class="line">//发件人</span><br><span class="line">msg.setFrom(new InternetAddress(USER_NAME));</span><br><span class="line">//收件人</span><br><span class="line">msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(USER_NAME, true));</span><br><span class="line">msg.setSubject(title);</span><br><span class="line">msg.setText(content);</span><br><span class="line">msg.setSentDate(new Date());</span><br><span class="line">Transport.send(msg);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      简单记录下Java使用Imap收邮件和Smtp发邮件。
    
    </summary>
    
      <category term="java" scheme="http://masaka.acehalo.com/categories/java/"/>
    
    
      <category term="教程" scheme="http://masaka.acehalo.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用Gradle构建Java项目中文乱码问题解决</title>
    <link href="http://masaka.acehalo.com/2020/02/23/idea-gradle-utf8/"/>
    <id>http://masaka.acehalo.com/2020/02/23/idea-gradle-utf8/</id>
    <published>2020-02-23T12:30:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>今天用Java写个工具的时候，遇到了中文乱码问题，记录下解决方式，改了两个地方。</p><ol><li><p>gradle.build文件增加：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = &quot;UTF-8&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>IDEA配置，Help-&gt;Edit Custom VM Options 增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=utf-8</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      在Windows下使用IDEA创建Gradle的Java项目后，Run的时候遇到乱码。记录下解决方式。
    
    </summary>
    
      <category term="other" scheme="http://masaka.acehalo.com/categories/other/"/>
    
    
      <category term="other" scheme="http://masaka.acehalo.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列6</title>
    <link href="http://masaka.acehalo.com/2019/05/18/leetcode-6/"/>
    <id>http://masaka.acehalo.com/2019/05/18/leetcode-6/</id>
    <published>2019-05-18T19:14:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>时隔好久，我又回来更新了。。。  </p><h3 id="938-Range-Sum-of-BST"><a href="#938-Range-Sum-of-BST" class="headerlink" title="938. Range Sum of BST"></a>938. Range Sum of BST</h3><p><a href="https://leetcode.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>直接递归遍历就好</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def rangeSumBST(self, root: TreeNode, L: int, R: int) -&gt; int:</span><br><span class="line">        result = 0</span><br><span class="line">        val = root.val;</span><br><span class="line">        if L &lt;= val &lt;= R:</span><br><span class="line">            result = val</span><br><span class="line"></span><br><span class="line">        l = 0</span><br><span class="line">        if root.left is not None:</span><br><span class="line">            l = self.rangeSumBST(root.left, L, R)</span><br><span class="line"></span><br><span class="line">        r = 0</span><br><span class="line">        if root.right is not None:</span><br><span class="line">            r = self.rangeSumBST(root.right, L, R)</span><br><span class="line"></span><br><span class="line">        return result + l + r</span><br></pre></td></tr></table></figure><h3 id="709-To-Lower-Case"><a href="#709-To-Lower-Case" class="headerlink" title="709. To Lower Case"></a>709. To Lower Case</h3><p><a href="https://leetcode.com/problems/to-lower-case/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>无</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def toLowerCase(self, str: str) -&gt; str:</span><br><span class="line">        return str.lower()</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p><a href="https://leetcode.com/problems/max-increase-to-keep-city-skyline/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>遍历二维数组，选出每列的最小值，和每行的最小值，然后再遍历二维数组，计算每个位置与min(当前行最小值，当前列最小值)的差值</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        max_top_bottom = [0 for i in range(len(grid[0]))]</span><br><span class="line">        for j in range(len(grid[0])):</span><br><span class="line">            lst = []</span><br><span class="line">            for i in range(len(grid)):</span><br><span class="line">                lst.append(grid[i][j])</span><br><span class="line">            max_top_bottom[j] = max(lst)</span><br><span class="line"></span><br><span class="line">        max_left_right = [0 for i in range(len(grid))]</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            lst = []</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                lst.append(grid[i][j])</span><br><span class="line">            max_left_right[i] = max(lst)</span><br><span class="line"></span><br><span class="line">        result = 0;</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[i])):</span><br><span class="line">                h = grid[i][j]</span><br><span class="line">                r = min(max_top_bottom[j], max_left_right[i]) - h</span><br><span class="line">                result = result + r</span><br><span class="line"></span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      时隔好久，我又回来更新了。。。每天刷几道leetcode题目系列，解法不一定是最优的 【938. Range Sum of BST】【709. To Lower Case】【807. Max Increase to Keep City Skyline】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列day5</title>
    <link href="http://masaka.acehalo.com/2019/03/17/leetcode-day5/"/>
    <id>http://masaka.acehalo.com/2019/03/17/leetcode-day5/</id>
    <published>2019-03-17T23:50:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="832-Flipping-an-Image"><a href="#832-Flipping-an-Image" class="headerlink" title="832. Flipping an Image"></a>832. Flipping an Image</h3><p><a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>无</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flipAndInvertImage(self, A: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        rows = []</span><br><span class="line">        for row in A:</span><br><span class="line">            items = []</span><br><span class="line">            row.reverse()</span><br><span class="line">            for item in row:</span><br><span class="line">                items.append(1 - item)</span><br><span class="line">            rows.append(items)</span><br><span class="line">        return rows</span><br></pre></td></tr></table></figure><h3 id="657-Robot-Return-to-Origin"><a href="#657-Robot-Return-to-Origin" class="headerlink" title="657. Robot Return to Origin"></a>657. Robot Return to Origin</h3><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>无</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def judgeCircle(self, moves: str) -&gt; bool:</span><br><span class="line">        up_count = 0</span><br><span class="line">        down_count = 0</span><br><span class="line">        left_count = 0</span><br><span class="line">        right_count = 0</span><br><span class="line">        for step in moves:</span><br><span class="line">            if step == &quot;U&quot;:</span><br><span class="line">                up_count = up_count + 1</span><br><span class="line">            elif step == &quot;D&quot;:</span><br><span class="line">                down_count = down_count + 1</span><br><span class="line">            elif step == &quot;L&quot;:</span><br><span class="line">                left_count = left_count + 1</span><br><span class="line">            elif step == &quot;R&quot;:</span><br><span class="line">                right_count = right_count + 1</span><br><span class="line">        return (up_count == down_count) and (left_count == right_count)</span><br></pre></td></tr></table></figure><p>刷了两道简单的题，然后睡觉，晚安。</p>]]></content>
    
    <summary type="html">
    
      每天刷几道leetcode题目系列，解法不一定是最优的 【832. Flipping an Image】 &amp;&amp; 【657. Robot Return to Origin】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列day4</title>
    <link href="http://masaka.acehalo.com/2019/03/15/leetcode-day4/"/>
    <id>http://masaka.acehalo.com/2019/03/15/leetcode-day4/</id>
    <published>2019-03-15T23:53:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="771-Jewels-and-Stones"><a href="#771-Jewels-and-Stones" class="headerlink" title="771. Jewels and Stones"></a>771. Jewels and Stones</h3><p><a href="https://leetcode.com/problems/jewels-and-stones/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>无</p><p>code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numJewelsInStones(self, J: str, S: str) -&gt; int:</span><br><span class="line">        c = 0</span><br><span class="line">        for i in S:</span><br><span class="line">            if i in J:</span><br><span class="line">                c = c + 1</span><br><span class="line">        return c</span><br></pre></td></tr></table></figure></p><p>今天困了，简单刷一道题就睡了</p>]]></content>
    
    <summary type="html">
    
      每天刷几道leetcode题目系列，解法不一定是最优的 【771. Jewels and Stones】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列day3</title>
    <link href="http://masaka.acehalo.com/2019/03/15/leetcode-day3/"/>
    <id>http://masaka.acehalo.com/2019/03/15/leetcode-day3/</id>
    <published>2019-03-15T02:15:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h3><p><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">题目链接</a></p><p>这题做的心态崩了，写的时候总是有问题，最后选择了保证可读性。虽然代码看起来操作比较复杂耗时，其实它还是O(1)的复杂度。</p><p>解题思路：<br>1.数据用哈希表存<br>2.访问次序的话需要保存一个最近访问的节点指针，和一个最早访问的节点指针，因为要O(1)的复杂度，所以肯定不能用纯链表保存，如果访问到链表中间的数据，时间复杂度肯定不是O(1)</p><p>3.因为心态崩了，所以把Get操作分解成先获取值，然后执行Delete操作，然后再执行Add操作。<br>4.因为心态崩了，所以做Add操作前先执行Delete操作。<br>5.之所以像上面提到的那么做，是因为，这样就可以把精力集中到处理Add和Delete操作上，只要这两个操作处理好两个头尾指针就好</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">class LRUCache:</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity: int):</span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.node_wrap = NodeWrap()</span><br><span class="line"></span><br><span class="line">    def get(self, key: int) -&gt; int:</span><br><span class="line">        return self.node_wrap.get(key)</span><br><span class="line"></span><br><span class="line">    def put(self, key: int, value: int) -&gt; None:</span><br><span class="line">        self.node_wrap.add(key, value)</span><br><span class="line">        if self.node_wrap.get_len() &gt; self.cap:</span><br><span class="line">            self.node_wrap.delete_oldest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, val, older, newer):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.older = older</span><br><span class="line">        self.newer = newer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NodeWrap:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.newest = None</span><br><span class="line">        self.oldest = None</span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def get(self, key):</span><br><span class="line">        if key not in self.dic:</span><br><span class="line">            return -1</span><br><span class="line"></span><br><span class="line">        val = self.dic[key].val</span><br><span class="line">        self.delete(key)</span><br><span class="line">        self.add(key, val)</span><br><span class="line">        return val</span><br><span class="line"></span><br><span class="line">    def add(self, key, val):</span><br><span class="line">        self.delete(key)</span><br><span class="line">        node = Node(key, val, None, None)</span><br><span class="line">        self.dic[key] = node</span><br><span class="line"></span><br><span class="line">        if self.newest is not None:</span><br><span class="line">            self.newest.newer = node</span><br><span class="line">            node.older = self.newest</span><br><span class="line"></span><br><span class="line">        self.newest = node</span><br><span class="line">        if self.oldest is None:</span><br><span class="line">            self.oldest = node</span><br><span class="line"></span><br><span class="line">    def delete(self, key):</span><br><span class="line">        if key not in self.dic:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        node = self.dic[key]</span><br><span class="line"></span><br><span class="line">        if self.newest is not None and self.newest.key == node.key:</span><br><span class="line">            self.newest = node.older</span><br><span class="line">            if self.newest is not None:</span><br><span class="line">                self.newest.newer = None</span><br><span class="line"></span><br><span class="line">        if self.oldest is not None and self.oldest.key == node.key:</span><br><span class="line">            self.oldest = node.newer</span><br><span class="line">            if self.oldest is not None:</span><br><span class="line">                self.oldest.older = None</span><br><span class="line"></span><br><span class="line">        if node.newer is not None:</span><br><span class="line">            node.newer.older = node.older</span><br><span class="line"></span><br><span class="line">        if node.older is not None:</span><br><span class="line">            node.older.newer = node.newer</span><br><span class="line"></span><br><span class="line">        del self.dic[key]</span><br><span class="line"></span><br><span class="line">    def delete_oldest(self):</span><br><span class="line">        if self.oldest is not None:</span><br><span class="line">            self.delete(self.oldest.key)</span><br><span class="line"></span><br><span class="line">    def get_len(self):</span><br><span class="line">        return len(self.dic)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">cache = LRUCache(2)</span><br><span class="line"></span><br><span class="line">cache.put(1, 1)</span><br><span class="line">cache.put(2, 2)</span><br><span class="line">print(cache.get(1))</span><br><span class="line">cache.put(3, 3)</span><br><span class="line">print(cache.get(2))</span><br><span class="line">cache.put(4, 4)</span><br><span class="line">print(cache.get(1))</span><br><span class="line">print(cache.get(3))</span><br><span class="line">print(cache.get(4))</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">cache = LRUCache(2)</span><br><span class="line"></span><br><span class="line">cache.put(2, 1)</span><br><span class="line">cache.put(1, 1)</span><br><span class="line">cache.put(2, 3)</span><br><span class="line">cache.put(4, 1)</span><br><span class="line">print(cache.get(1))</span><br><span class="line">print(cache.get(2))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      每天刷几道leetcode题目系列，解法不一定是最优的 【146. LRU Cache】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列day2</title>
    <link href="http://masaka.acehalo.com/2019/03/13/leetcode-day2/"/>
    <id>http://masaka.acehalo.com/2019/03/13/leetcode-day2/</id>
    <published>2019-03-13T22:58:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路:<br>1.对两个列表进行归并排序<br>2.找到中间位置即可</p><p>对两个列表进行归并排序的思路:<br>1.获取每个列表的第一个元素<br>2.将小的那个值放入新的列表中，指针向后移一位</p><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:</span><br><span class="line">        nums = []</span><br><span class="line">        nums1_i = 0</span><br><span class="line">        nums2_i = 0</span><br><span class="line">        nums1_first = None</span><br><span class="line">        nums2_first = None</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            if nums1_i &lt; len(nums1) and nums1_first is None:</span><br><span class="line">                nums1_first = nums1[nums1_i]</span><br><span class="line">                nums1_i = nums1_i+1</span><br><span class="line"></span><br><span class="line">            if nums2_i &lt; len(nums2) and nums2_first is None:</span><br><span class="line">                nums2_first = nums2[nums2_i]</span><br><span class="line">                nums2_i = nums2_i+1</span><br><span class="line"></span><br><span class="line">            if nums1_first is None and nums2_first is None:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            if nums1_first is None:</span><br><span class="line">                nums.append(nums2_first)</span><br><span class="line">                nums2_first = None</span><br><span class="line">            elif nums2_first is None:</span><br><span class="line">                nums.append(nums1_first)</span><br><span class="line">                nums1_first = None</span><br><span class="line">            elif nums1_first&lt;nums2_first:</span><br><span class="line">                nums.append(nums1_first)</span><br><span class="line">                nums1_first = None</span><br><span class="line">            elif nums2_first&lt;nums1_first:</span><br><span class="line">                nums.append(nums2_first)</span><br><span class="line">                nums2_first = None</span><br><span class="line">            else:</span><br><span class="line">                nums.append(nums1_first)</span><br><span class="line">                nums.append(nums2_first)</span><br><span class="line">                nums1_first=None</span><br><span class="line">                nums2_first=None</span><br><span class="line"></span><br><span class="line">        if len(nums) % 2 ==0:</span><br><span class="line">            idx = len(nums)//2</span><br><span class="line">            r = (nums[idx]+nums[idx-1])/2</span><br><span class="line">        else:</span><br><span class="line">            idx = (len(nums)-1)//2</span><br><span class="line">            r = nums[idx]</span><br><span class="line">        </span><br><span class="line">        return r</span><br></pre></td></tr></table></figure><h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目链接</a></p><p>这里利用了Python的一些特性，比如int本身就是大整数类型</p><p>解题思路：<br>1.把链表弄成数字<br>2.数字相加<br>3.将结果转换会链表</p><p>code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        lst1 = []</span><br><span class="line">        lst1.append(str(l1.val))</span><br><span class="line">        while l1.next is not None:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            lst1.append(str(l1.val))</span><br><span class="line">            </span><br><span class="line">        lst2 = []</span><br><span class="line">        lst2.append(str(l2.val))</span><br><span class="line">        while l2.next is not None:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            lst2.append(str(l2.val))</span><br><span class="line">            </span><br><span class="line">        lst1.reverse()</span><br><span class="line">        lst2.reverse()</span><br><span class="line"></span><br><span class="line">        num1 = &quot;&quot;.join(lst1)</span><br><span class="line">        num2 = &quot;&quot;.join(lst2)</span><br><span class="line"></span><br><span class="line">        num = int(num1)+int(num2)</span><br><span class="line"></span><br><span class="line">        lst = []</span><br><span class="line">        for i in str(num):</span><br><span class="line">            lst.append(i)</span><br><span class="line"></span><br><span class="line">        lst.reverse()</span><br><span class="line"></span><br><span class="line">        first_node = None</span><br><span class="line">        pre_node = None</span><br><span class="line"></span><br><span class="line">        for i in lst:</span><br><span class="line">            node = ListNode(i)</span><br><span class="line">            if pre_node is not None:</span><br><span class="line">                pre_node.next = node</span><br><span class="line">            else:</span><br><span class="line">                first_node = node</span><br><span class="line">            pre_node = node</span><br><span class="line"></span><br><span class="line">        return first_node</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      每天刷几道leetcode题目系列，解法不一定是最优的 【4. Median of Two Sorted Arrays】&amp;&amp; 【2. Add Two Numbers】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>每天几道Leetcode系列day1</title>
    <link href="http://masaka.acehalo.com/2019/03/13/leetcode-day1/"/>
    <id>http://masaka.acehalo.com/2019/03/13/leetcode-day1/</id>
    <published>2019-03-13T00:28:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目链接</a></p><p>解题思路：<br>1.需要一个空list用于保存遍历到的字符<br>2.每当遍历到的字符在list里出现时，从出现这个字符的后一个位置截取这个list<br>3.每次加入字符后记录这个list的长度，取最大的值</p><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        input_str = s</span><br><span class="line">        mx = 0</span><br><span class="line"></span><br><span class="line">        strs = []</span><br><span class="line">        for s in input_str:</span><br><span class="line">            try:</span><br><span class="line">                idx = strs.index(s)</span><br><span class="line">            except:</span><br><span class="line">                idx = -1</span><br><span class="line">            if idx &gt;=0:</span><br><span class="line">                if idx == len(strs)-1:</span><br><span class="line">                    strs = []</span><br><span class="line">                else:</span><br><span class="line">                    strs = strs[idx+1:]</span><br><span class="line">            strs.append(s)</span><br><span class="line">            if len(strs) &gt; mx:</span><br><span class="line">                mx = len(strs)</span><br><span class="line"></span><br><span class="line">        return mx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      每天刷几道leetcode题目系列，解法不一定是最优的 【3. Longest Substring Without Repeating Characters】
    
    </summary>
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://masaka.acehalo.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>通过微博API发送微博</title>
    <link href="http://masaka.acehalo.com/2018/10/14/post-weibo-d1db1d9f/"/>
    <id>http://masaka.acehalo.com/2018/10/14/post-weibo-d1db1d9f/</id>
    <published>2018-10-14T20:00:00.000Z</published>
    <updated>2020-12-23T01:10:13.773Z</updated>
    
    <content type="html"><![CDATA[<p>首先到 <a href="http://open.weibo.com/development" target="_blank" rel="noopener">http://open.weibo.com/development</a> 创建一个微连接，应用类型选择其他，之后应用分类选择桌面客户端。<br>之后会自动跳到应用的详情页。<br>因为新的发微博的接口必须要带个URL，所以应用基本信息里有个安全域名，需要选择是，之后填上自己的域名，这个域名就是每次发微博需要带的那个URL的域名。如果没有可以填 weibo.com ，之后发微博的时候带上自己的微博主页地址。<br>其他信息随便填一填。<br>发微博的接口文档是这个 <a href="http://open.weibo.com/wiki/2/statuses/share" target="_blank" rel="noopener">http://open.weibo.com/wiki/2/statuses/share</a><br>这个接口需要一个access_token。<br>我们可以通过这个地址获得 <a href="http://open.weibo.com/tools/console" target="_blank" rel="noopener">http://open.weibo.com/tools/console</a><br>因为是自己的应用，同时是自己的账号，所以这个access_token有五年的有效期。<br>下面就是发微博的代码了，我用python写的，用别的语言也可以，access_token作为参数放到url后面，消息体用form表单urlencode方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">status = &quot;测试内容 &gt;_自动发布 https://weibo.com/friendlykai&quot;</span><br><span class="line">params = &#123; &quot;access_token&quot; : &quot;your_access_token&quot; &#125;</span><br><span class="line">data = &#123; &quot;status&quot; : status &#125;</span><br><span class="line">url = &quot;https://api.weibo.com/2/statuses/share.json&quot;</span><br><span class="line">r = requests.post(url=url,params=params,data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><p>到这里就可以成功发送微博了。</p>]]></content>
    
    <summary type="html">
    
      闲着无聊研究了下怎么通过微博的API发送微博。
    
    </summary>
    
      <category term="其他" scheme="http://masaka.acehalo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>FutureTask和DatagramChannel引发的死锁</title>
    <link href="http://masaka.acehalo.com/2018/06/05/java-a68836a5/"/>
    <id>http://masaka.acehalo.com/2018/06/05/java-a68836a5/</id>
    <published>2018-06-05T00:00:00.000Z</published>
    <updated>2020-12-23T01:10:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上服务出现了一次死锁，顺着jstack的log查了查原因。发现是jdk的bug，查看openjdk的bug列表，有类似的问题，官方将在11版本修复。</p><p>我下载了官网最新的jdk，8u171 8u172和jdk 10.0.1都能复现。</p><p><a href="https://bugs.openjdk.java.net/browse/JDK-8138622" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8138622</a></p><p>这篇文章涉及到的jdk源码我没有贴上来，因为太长了，需要读者自己查看源码。</p><h2 id="0x01-问题复现代码"><a href="#0x01-问题复现代码" class="headerlink" title="0x01 问题复现代码"></a>0x01 问题复现代码</h2><p>根据线上出问题的服务的jstack信息分析后，编写问题复现代码。由于是udp通信，所有需要服务端和客户端。客户端采用java编写，服务端为了方便，采用python3编写。  </p><ul><li><p>客户端代码 ( java ) ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    private static ExecutorService threadPool = new ThreadPoolExecutor(40, 80, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1000));</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">            RunClass task = new RunClass();</span><br><span class="line">            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task);</span><br><span class="line">            threadPool.submit(futureTask);</span><br><span class="line">            try &#123;</span><br><span class="line">                String a = futureTask.get(3, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (TimeoutException e) &#123;</span><br><span class="line">                futureTask.cancel(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RunClass implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        go();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void go() throws IOException &#123;</span><br><span class="line">        DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        channel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));</span><br><span class="line">        byte[] b = &quot;123&quot;.getBytes(&quot;utf-8&quot;);</span><br><span class="line">        System.out.println(b.length);</span><br><span class="line">        ByteBuffer byteBuffers = ByteBuffer.allocate(b.length);</span><br><span class="line">        byteBuffers.put(b);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        byteBuffers.flip();</span><br><span class="line">        channel.write(byteBuffers);</span><br><span class="line">        while (selector.select() &gt; 0) &#123;</span><br><span class="line">            Iterator iterator = selector.selectedKeys().iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    key = (SelectionKey) iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    if (key.isReadable()) &#123;</span><br><span class="line">                        reveice(key);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (key.isWritable()) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; catch (ClosedChannelException cex) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reveice(SelectionKey key) throws IOException &#123;</span><br><span class="line">        DatagramChannel channel = (DatagramChannel) key.channel();</span><br><span class="line">        ByteBuffer byteBuffers2 = ByteBuffer.allocate(1024);</span><br><span class="line">        channel.receive(byteBuffers2);</span><br><span class="line">        Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line">        CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">        byteBuffers2.flip();</span><br><span class="line">        CharBuffer charBuffer = decoder.decode(byteBuffers2.asReadOnlyBuffer());</span><br><span class="line">        System.out.println(charBuffer.toString());</span><br><span class="line">        System.out.println(&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端代码 ( python3 ) ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"># 绑定 客户端口和地址:</span><br><span class="line">s.bind((&apos;127.0.0.1&apos;, 9999))</span><br><span class="line">print(&apos;Bind UDP on 9999...&apos;)</span><br><span class="line">while True:</span><br><span class="line">    # 接收数据 自动阻塞 等待客户端请求:</span><br><span class="line">    data,addr=s.recvfrom(1024)</span><br><span class="line">    print(&quot;Receive from %s:%s&quot;% addr)</span><br><span class="line">    print(&quot;Receive %s&quot;% data.decode(&quot;utf-8&quot;))</span><br><span class="line">    s.sendto(&quot;Hello &quot;.encode(&quot;utf-8&quot;)+ data,addr)</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x02-异常栈"><a href="#0x02-异常栈" class="headerlink" title="0x02 异常栈"></a>0x02 异常栈</h2><p>JStack如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&quot;main&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fb81b149b00 (object 0x0000000747b8ffb8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;pool-1-thread-11&quot;</span><br><span class="line">&quot;pool-1-thread-11&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fb81a918200 (object 0x0000000747d208b0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;main&quot;</span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&quot;main&quot;:</span><br><span class="line">    at sun.nio.ch.DatagramChannelImpl.implCloseSelectableChannel(java.base@10.0.1/DatagramChannelImpl.java:1005)</span><br><span class="line">    - waiting to lock &lt;0x0000000747b8ffb8&gt; (a java.lang.Object)</span><br><span class="line">    at java.nio.channels.spi.AbstractSelectableChannel.implCloseChannel(java.base@10.0.1/AbstractSelectableChannel.java:234)</span><br><span class="line">    at java.nio.channels.spi.AbstractInterruptibleChannel$1.interrupt(java.base@10.0.1/AbstractInterruptibleChannel.java:162)</span><br><span class="line">    - locked &lt;0x0000000747b8ff68&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.Thread.interrupt(java.base@10.0.1/Thread.java:1019)</span><br><span class="line">    - locked &lt;0x0000000747d208b0&gt; (a java.lang.Object)</span><br><span class="line">    at java.util.concurrent.FutureTask.cancel(java.base@10.0.1/FutureTask.java:173)</span><br><span class="line">    at main.App.main(App.java:33)</span><br><span class="line">&quot;pool-1-thread-11&quot;:</span><br><span class="line">    at java.lang.Thread.blockedOn(java.base@10.0.1/Thread.java:239)</span><br><span class="line">    - waiting to lock &lt;0x0000000747d208b0&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.System$2.blockedOn(java.base@10.0.1/System.java:2115)</span><br><span class="line">    at java.nio.channels.spi.AbstractInterruptibleChannel.blockedOn(java.base@10.0.1/AbstractInterruptibleChannel.java:208)</span><br><span class="line">    at java.nio.channels.spi.AbstractInterruptibleChannel.end(java.base@10.0.1/AbstractInterruptibleChannel.java:195)</span><br><span class="line">    at sun.nio.ch.DatagramChannelImpl.receive(java.base@10.0.1/DatagramChannelImpl.java:379)</span><br><span class="line">    - locked &lt;0x0000000747b8ff98&gt; (a java.lang.Object)</span><br><span class="line">    at sun.nio.ch.DatagramChannelImpl.connect(java.base@10.0.1/DatagramChannelImpl.java:754)</span><br><span class="line">    - locked &lt;0x0000000747b8ff88&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x0000000747b8ffb8&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x0000000747b8ffa8&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x0000000747b8ff98&gt; (a java.lang.Object)</span><br><span class="line">    at main.RunClass.go(App.java:51)</span><br><span class="line">    at main.RunClass.call(App.java:44)</span><br><span class="line">    at main.RunClass.call(App.java:40)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(java.base@10.0.1/FutureTask.java:264)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(java.base@10.0.1/Executors.java:514)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(java.base@10.0.1/FutureTask.java:264)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@10.0.1/ThreadPoolExecutor.java:1135)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@10.0.1/ThreadPoolExecutor.java:635)</span><br><span class="line">    at java.lang.Thread.run(java.base@10.0.1/Thread.java:844)</span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure></p><h2 id="0x03-死锁发生条件"><a href="#0x03-死锁发生条件" class="headerlink" title="0x03 死锁发生条件"></a>0x03 死锁发生条件</h2><ul><li><p>String a = futureTask.get(3, TimeUnit.MILLISECONDS);<br>超时时间设置的较短</p></li><li><p>futureTask.cancel(true);<br>cancel传入true</p></li></ul><h2 id="0x04-分析"><a href="#0x04-分析" class="headerlink" title="0x04 分析"></a>0x04 分析</h2><p>根据异常栈可知：</p><ul><li>main线程拿着Thread对象的blockerLock锁，在等待DatagramChannelImpl对象的stateLock锁</li><li>pool-1-thread-11线程拿着DatagramChannelImpl对象的stateLock锁，在等待Thread对象的blockerLock锁</li></ul><p>那么，为什么会出现这种情况呢？我们跟着源码看看代码做了什么。<br>我们先来看执行UDP通信的线程在做什么：  </p><p>首先，DatagramChannel对象执行了connect方法。udp和tcp不一样，udp通信是不需要建立连接的，那么这个connect是在干什么呢？根据源码我们可以看到，这里主要是为了清除已经收到的udp包。这个方法首先就拿到了三个锁，其中就有我们关注的stateLock锁。</p><p>为什么会有stateLock锁呢？因为这里有个状态转换，这个DatagramChannel对象的状态要从ST_UNINITIALIZED转换到ST_CONNECTED，这里只有完成了connect方法里的所有步骤，才算完成状态转换，才会释放锁。</p><p>我们继续看connect方法中的receive方法做了些什么。receive方法中，在执行接受数据前执行了一个begin方法，在完成后执行了end方法。我们先来看看begin方法，begin方法调用了一个叫做blockedOn的方法，这里是向当前线程注册了一个被interrupt之后的事件，也就是说当前线程被interrupt的话，会调用注册的这个方法。blockedOn方法里会拿到当前线程的blockerLock锁，这里我们关注的第二个锁就出现了。end方法，其实就是取消注册当前线程被interrupt之后的事件，end方法也会调用blockedOn方法，所以也需要拿到blockerLock锁。</p><p>接下来，我们再来看看main线程做了些什么：</p><p>main线程在调用FutureTask对象的get方法超时之后，就调用了FutureTask对象的cancel方法。如果cancel方法传入的参数为true，那么在cancel方法里，会调用执行线程的interrupt方法，也就是上面说的执行udp通信的线程的interrupt方法。</p><p>main线程调用了执行线程的interrupt方法后，执行线程会拿到自己的Thread对象的blockerLock锁，然后调用通过blockedOn方法注册的事件。</p><p>翻看源码我们可以发现，DatagramChannel对象通过blockedOn方法注册的事件就是自己的implCloseSelectableChannel方法，而调用implCloseSelectableChannel方法时，会拿到stateLock锁。</p><p>结合着源码和异常栈，我们可以得出死锁流程是这个样子的：</p><ol><li><p>首先udp线程拿着stateLock锁准备接受数据。</p></li><li><p>然后在真正读数据之前向当前线程注册了一个interrupt事件。</p></li><li><p>之后读完数据之后准备获取当前线程的blockerLock锁取消注册的interrupt事件。</p></li><li><p>这时，因为timeout时间已到，触发线程的interrupt事件，线程拿着blockerLock锁去调用implCloseSelectableChannel方法，而implCloseSelectableChannel方法需要stateLock锁。</p></li></ol><p>至此，死锁就形成了。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>对于死锁问题，只要跟着异常栈和源码慢慢分析就好。</p>]]></content>
    
    <summary type="html">
    
      最近线上服务出现了一次死锁，顺着jstack的log查了查原因。发现是jdk的bug，查看openjdk的bug列表，有类似的问题，官方将在11版本修复。
    
    </summary>
    
      <category term="java" scheme="http://masaka.acehalo.com/categories/java/"/>
    
    
      <category term="问题排查" scheme="http://masaka.acehalo.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
</feed>
